---
title: "ProviderScoring"
author: "Rohan"
output: pdf_document
---

```{r}
library(plyr)
```

```{r}
nyopth <- read.csv("nyopth.csv")
agi <- read.csv("agi.csv")
```
```{r}
nyopth.zip = nyopth[,c(2,12)]
func <- function(x){
  substr(x,1,5)
}
nyopth.zip$nppes_provider_zip <- lapply(nyopth.zip$nppes_provider_zip,FUN = func)
nyopth.zip$nppes_provider_zip <- as.numeric(nyopth.zip$nppes_provider_zip)
nyopth.zip = nyopth.zip[!duplicated(nyopth.zip),]
```
```{r}
agi <- agi[,c(1,5)]
```

```{r}
nyopth <- nyopth[,c(2,8,12,16,17,18,20,21,22,23,24,25,26,27,28,29)]

tophcpcs <- names((sort(table(nyopth$hcpcs_code),decreasing = TRUE))[1:10])

#scores<-vector(mode="list",length = length(unique(nyopth$npi)),x=0)
scores<-rep(x = 0,times = length(unique(nyopth$npi)))

names(scores) <- unique(nyopth$npi)
```

```{r}
scoreFunction <- function(rowdiff, q, col){
  score = 0
  
  rowscore = rowdiff[col]
  if (rowscore>=q[1] && rowscore<q[2]){
    score = 0
  }
  else if (rowscore>=q[2] && rowscore<q[3]){
    score = 1
  }
  else if (rowscore>=q[3] && rowscore<q[4]){
    score = 2
  }
  else{
    score = 3
  }
  score
}
```

We loop over all the top hcpcs codes and add to the scores based on the spread of the submitted - payment amount and based on the beneficiaries counts.
```{r}
for (i in tophcpcs){
  tmp = nyopth[nyopth$hcpcs_code==i,]
  tmp.avgpayment <- ddply(tmp,~npi,summarise,mean=mean(average_medicare_payment_amt))
  tmp.avgsubmitted <- ddply(tmp,~npi,summarise,mean=mean(average_submitted_chrg_amt))
  tmp.spread <- merge(tmp.avgpayment,tmp.avgsubmitted,by.x = "npi",by.y = "npi")
  #TODO:Need to reassess agi index to be >=1
  tmp.spread$diff = tmp.spread$mean.y - tmp.spread$mean.x

  t1 = join(x = tmp.spread, y = nyopth.zip, by = "npi")
  colnames(t1)[5] <- "ZIP"
  t2 = join(x = t1, y = agi)
  
  t2 = transform(t2, diff2 = diff/Indx)
  t2 = t2[complete.cases(t2),]
  
  #some kind of function that will give out points 
  #depending on the quartile that the npi falls under
  q<-quantile(t2$diff2)
  t2$sc <- apply(t2, 1, FUN = scoreFunction,q = q, col = 7)
  for (j in 1:nrow(tmp.spread)){
    scores[as.character(t2[j,1])] = scores[as.character(t2[j,1])]+t2[j,8]
  }
  
  #TODO:Need to dispense points based on number of beneficiaries
  
}
```


```{r}
sort(scores,decreasing = TRUE)[1:10]
```


```{r}
prov <- nyopth[nyopth$npi==1053315416,]
prov
```